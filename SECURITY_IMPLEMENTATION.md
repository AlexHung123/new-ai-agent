# Security Implementation Guide: Token-Based Authentication

## Overview
This guide explains how to implement secure token-based authentication for your AI Agent application to prevent userId tampering.

---

## üî¥ Problem Identified
**Previously:** userId was stored in localStorage and sent from client-side, allowing users to:
- Modify userId in browser DevTools
- Access other users' chat history
- View/delete other users' data

**Now:** Token-based authentication with server-side verification ensures:
- ‚úÖ Server controls and verifies user identity
- ‚úÖ Tokens are cryptographically signed
- ‚úÖ Cannot be forged by client
- ‚úÖ Automatic expiration

---

## üìã Implementation Steps

### Step 1: Generate Token in Your Parent Application

Your parent application uses JWT tokens with this structure:

```javascript
const jwt = require('jsonwebtoken');

function generateAuthToken(userId, username, sessionId) {
  const secret = 'secret'; // Same secret as in AI Agent .env.local
  
  return jwt.sign(
    {
      id: userId,           // Used as userId in AI Agent
      username: username,
      sessionId: sessionId
    },
    secret,
    { expiresIn: '24h' }    // Token expires in 24 hours
  );
}

// Example: Generate token when user logs in
const authToken = generateAuthToken(user.id, user.username, session.id);
```

**Important:** The JWT secret in your parent app must match `JWT_SECRET` in the AI Agent's `.env.local` file.

---

### Step 2: Update Your iframe to Pass Token

**Parent Application Code:**
```jsx
// Before (Insecure)
<iframe
  src={`http://192.168.56.1:3001/itms/ai/agents?userId=${userId}`}
  style={{ width: '100%', height: '100vh', border: 'none' }}
  title="AI Agent"
/>

// After (Secure)
<iframe
  src={`http://192.168.56.1:3001/itms/ai/agents?token=${authToken}`}
  style={{ width: '100%', height: '100vh', border: 'none' }}
  title="AI Agent"
/>
```

Where `authToken` is generated by your backend using Step 1.

---

### Step 3: Configure JWT Secret

The AI Agent is configured to use JWT tokens matching your parent application's structure.

**File: `.env.local`** (already created)
```env
# This MUST match the secret used in your parent application
JWT_SECRET=secret
```

**Token Structure Expected:**
```json
{
  "id": "user123",           // Mapped to userId
  "username": "john.doe",
  "sessionId": "session456",
  "iat": 1234567890,          // Issued at (auto)
  "exp": 1234654290           // Expires at (auto)
}
```

**How It Works:**
1. Your parent app generates JWT with `id`, `username`, `sessionId`
2. AI Agent receives token via URL: `?token=eyJhbGc...`
3. Middleware verifies signature using `JWT_SECRET`
4. Extracts `userId` from `payload.id` field
5. Injects verified `userId` into request headers

---

### Step 4: Test the Implementation

1. **Start your AI Agent:**
```bash
npm run dev
```

2. **Open the iframe with a valid token:**
```
http://192.168.56.1:3001/itms/ai/agents?token=YOUR_GENERATED_TOKEN
```

3. **Verify token is stored:**
Open browser DevTools ‚Üí Application ‚Üí Local Storage ‚Üí Check for `authToken`

4. **Test API requests:**
- View chat history
- Create a new chat
- Delete a chat
- All should work with the token, fail without it

---

## üîç How It Works

### Request Flow:
```
1. User logs into parent app
   ‚îî‚îÄ> Parent app generates token (JWT or session)

2. Parent app opens iframe with token in URL
   ‚îî‚îÄ> AI Agent: http://ai.example.com?token=abc123

3. AI Agent extracts token from URL
   ‚îî‚îÄ> Stores in localStorage as 'authToken'
   ‚îî‚îÄ> Removes userId from URL (backward compatibility)

4. User clicks "History"
   ‚îî‚îÄ> Frontend sends: Authorization: Bearer abc123

5. Middleware intercepts request
   ‚îî‚îÄ> Validates token (JWT verify or DB lookup)
   ‚îî‚îÄ> Extracts real userId from token
   ‚îî‚îÄ> Adds x-user-id header to request

6. API route receives request
   ‚îî‚îÄ> Gets userId from x-user-id header
   ‚îî‚îÄ> Queries database using VERIFIED userId
   ‚îî‚îÄ> Returns user's data
```

---

## üõ°Ô∏è Security Features

| Feature | How It Works |
|---------|--------------|
| **Token Signature** | Cryptographically signed, cannot be forged |
| **Server Verification** | Every request validated by middleware |
| **Automatic Expiration** | Tokens expire after set time (e.g., 24h) |
| **Header Injection** | Verified userId injected by middleware, not client |
| **Protected Routes** | All sensitive endpoints require valid token |

---

## üìù Environment Variables

Add to your `.env` file:

```env
# JWT Secret (if using JWT)
JWT_SECRET=your-very-secure-secret-key-here-change-this

# Database connections (already configured)
# ... existing database config ...
```

---

## üß™ Testing Scenarios

### Test 1: Valid Token
```bash
curl -H "Authorization: Bearer YOUR_TOKEN" \
  http://localhost:3001/itms/ai/api/chats
```
**Expected:** Returns user's chats

### Test 2: No Token
```bash
curl http://localhost:3001/itms/ai/api/chats
```
**Expected:** 401 Unauthorized

### Test 3: Invalid Token
```bash
curl -H "Authorization: Bearer fake-token" \
  http://localhost:3001/itms/ai/api/chats
```
**Expected:** 401 Invalid or expired token

### Test 4: Tampered Token (if using JWT)
Modify the payload part of a JWT token
**Expected:** 401 Invalid signature

---

## üîß Troubleshooting

### Issue: "Authentication token required"
**Solution:** 
- Ensure token is passed in URL: `?token=...`
- Check localStorage has `authToken` key
- Verify fetch requests include `Authorization` header

### Issue: "Invalid or expired token"
**Solution:**
- Check JWT_SECRET matches between parent app and AI agent
- Verify token hasn't expired
- For DB sessions, check expires_at timestamp

### Issue: "No userId found"
**Solution:**
- Token verification might be failing
- Check verifyToken.ts implementation
- Verify database query returns user_id correctly

---

## üéØ Next Steps (Optional Enhancements)

1. **Token Refresh:** Implement refresh tokens for seamless re-authentication
2. **Role-Based Access:** Add role checking in middleware
3. **Rate Limiting:** Prevent abuse with rate limits per user
4. **Audit Logging:** Log all authenticated requests
5. **Token Revocation:** Allow users to revoke active sessions

---

## üìö Files Modified

- ‚úÖ `src/middleware.ts` - Token verification middleware
- ‚úÖ `src/lib/auth/verifyToken.ts` - Token validation logic
- ‚úÖ `src/lib/utils/auth.ts` - Client-side auth utilities
- ‚úÖ `src/lib/hooks/useChat.tsx` - Updated to use tokens
- ‚úÖ `src/app/api/chats/route.ts` - Uses verified userId
- ‚úÖ `src/app/api/chats/[id]/route.ts` - Uses verified userId
- ‚úÖ `src/app/api/permissions/route.ts` - Uses verified userId
- ‚úÖ `src/app/library/page.tsx` - Sends auth headers
- ‚úÖ `src/app/agents/page.tsx` - Sends auth headers
- ‚úÖ `src/components/DeleteChat.tsx` - Sends auth headers

---

## ‚ö†Ô∏è Important Notes

1. **Backward Compatibility:** The userId system still works temporarily for migration
2. **HTTPS Required:** In production, ALWAYS use HTTPS to prevent token interception
3. **Secret Security:** Never commit JWT_SECRET to git - use environment variables
4. **Token Storage:** localStorage is acceptable for iframe scenarios; for standalone apps, consider httpOnly cookies

---

## ü§ù Support

If you encounter issues:
1. Check browser console for errors
2. Check server logs for verification failures
3. Verify token format matches your implementation choice
4. Ensure database connections are working

---

## ‚úÖ Implementation Checklist

- [ ] Choose token type (JWT or session-based)
- [ ] Implement token generation in parent app
- [ ] Update iframe URL to pass token instead of userId
- [ ] Configure verifyToken.ts with chosen method
- [ ] Set JWT_SECRET in .env (if using JWT)
- [ ] Test with valid token
- [ ] Test with invalid/missing token
- [ ] Verify userId cannot be manipulated
- [ ] Deploy to production with HTTPS

---

**Security Status:** üîí Secured with server-side token verification
